using System;
using System.Windows;
using System.Windows.Data;

namespace Anomaly_Detector.Converters
{
    public class BoolToVisibilityConverter : IValueConverter
    {
        public object Convert(object value, Type targetType, object parameter, System.Globalization.CultureInfo culture)
        {
            if (value is bool && (bool)value)
            {
                return Visibility.Visible;
            }
            return Visibility.Collapsed;
        }

        public object ConvertBack(object value, Type targetType, object parameter, System.Globalization.CultureInfo culture)
        {
            throw new NotImplementedException();
        }
    }
}
using System;
using System.Globalization;
using System.Windows.Data;

namespace Anomaly_Detector.Converters
{
    public class IndexToColumnConverter : IValueConverter
    {
        public object Convert(object value, Type targetType, object parameter, CultureInfo culture)
        {
            if (value is int index)
            {
                return index % 2; // Chia vào hai c?t (0 và 1)
            }
            return 0; // M?c d?nh là c?t 0 n?u l?i
        }

        public object ConvertBack(object value, Type targetType, object parameter, CultureInfo culture)
        {
            throw new NotImplementedException();
        }
    }
}
using System;
using System.Globalization;
using System.Windows.Data;
using System.Windows.Media.Imaging;

namespace Anomaly_Detector.Converters
{
    /// <summary>
    /// Converts a file path to a BitmapImage.
    /// </summary>
    public class PathToImageConverter : IValueConverter
    {
        public object Convert(object value, Type targetType, object parameter, CultureInfo culture)
        {
            string path = value as string;
            if (string.IsNullOrEmpty(path))
                return null;
            try
            {
                BitmapImage image = new BitmapImage();
                image.BeginInit();
                image.UriSource = new Uri(path, UriKind.Absolute);
                image.CacheOption = BitmapCacheOption.OnLoad;
                image.EndInit();
                return image;
            }
            catch
            {
                return null;
            }
        }
        public object ConvertBack(object value, Type targetType, object parameter, CultureInfo culture)
        {
            throw new NotImplementedException();
        }
    }
}
using System.Collections.ObjectModel;

namespace Anomaly_Detector.Models
{
    /// <summary>
    /// Represents the overall application settings including camera, PLC, and image processing configurations.
    /// </summary>
    public class ApplicationSettings
    {
        /// <summary>
        /// Gets or sets the collection of camera configurations.
        /// </summary>
        public ObservableCollection<CameraModel> Cameras { get; set; } = new ObservableCollection<CameraModel>();

        /// <summary>
        /// Gets or sets the PLC configuration.
        /// </summary>
        public PLCModel PLCConfiguration { get; set; } = new PLCModel();

        /// <summary>
        /// Gets or sets the collection of registered PLC endpoints.
        /// </summary>
        public ObservableCollection<PLCEndpoint> PLCEndpoints { get; set; } = new ObservableCollection<PLCEndpoint>();

        /// <summary>
        /// Gets or sets the settings for image preprocessing.
        /// </summary>
        public ImagePreprocessingSettings PreprocessingSettings { get; set; } = new ImagePreprocessingSettings();

        /// <summary>
        /// Gets or sets the folder path where images are stored.
        /// </summary>
        public string ImageStoragePath { get; set; } = string.Empty;

        /// <summary>
        /// Gets or sets the threshold value for image comparison or anomaly detection.
        /// </summary>
        public double Threshold { get; set; }

        /// <summary>
        /// Gets or sets the ordered collection of image preprocessing steps.
        /// </summary>
        public ObservableCollection<PreprocessingStep> PreprocessingSteps { get; set; } = new ObservableCollection<PreprocessingStep>();
    }
}
using System.ComponentModel;
using System.Windows.Media;
using System.Windows.Media.Imaging;

namespace Anomaly_Detector.Models
{
    /// <summary>
    /// Represents a camera configuration including its standard image, target image, threshold, and comparison message.
    /// </summary>
    public class CameraModel : INotifyPropertyChanged
    {
        public int CameraIndex { get; set; }
        public string? IPAddress { get; set; }
        public int? Port { get; set; }
        public string? Description { get; set; } = string.Empty;

        public string StandardImagePath { get; set; } = string.Empty;

        private BitmapSource _standardImage;
        public BitmapSource StandardImage
        {
            get => _standardImage;
            set { _standardImage = value; OnPropertyChanged(nameof(StandardImage)); }
        }

        private BitmapSource? _targetImage;
        public BitmapSource? TargetImage
        {
            get => _targetImage;
            set { _targetImage = value; OnPropertyChanged(nameof(TargetImage)); }
        }

        private double _threshold;
        public double Threshold
        {
            get => _threshold;
            set { _threshold = value; OnPropertyChanged(nameof(Threshold)); }
        }

        private string? _comparisonMessage;
        public string? ComparisonMessage
        {
            get => _comparisonMessage;
            set { _comparisonMessage = value; OnPropertyChanged(nameof(ComparisonMessage)); }
        }

        // New Property: Connection Status Color for Camera
        private string _connectionColor = "Gray";  // Default to gray (disconnected)
        public string ConnectionColor
        {
            get => _connectionColor;
            set { _connectionColor = value; OnPropertyChanged(nameof(ConnectionColor)); }
        }

        // New Property: Flag to indicate if the camera is connected
        private bool _isConnected;
        public bool IsConnected
        {
            get => _isConnected;
            set { _isConnected = value; OnPropertyChanged(nameof(IsConnected)); }
        }

        public event PropertyChangedEventHandler? PropertyChanged;
        protected void OnPropertyChanged(string propName)
        {
            PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propName));
        }
    }
}
namespace Anomaly_Detector.Models
{
    /// <summary>
    /// Represents settings for image preprocessing operations.
    /// </summary>
    public class ImagePreprocessingSettings
    {
        /// <summary>
        /// Gets or sets the brightness adjustment factor.
        /// </summary>
        public double Brightness { get; set; }

        /// <summary>
        /// Gets or sets the contrast adjustment factor.
        /// </summary>
        public double Contrast { get; set; }

        /// <summary>
        /// Gets or sets a value indicating whether to apply noise reduction.
        /// </summary>
        public bool ApplyNoiseReduction { get; set; }

        /// <summary>
        /// Gets or sets the noise reduction method (e.g., "Gaussian", "Bilateral").
        /// </summary>
        public string NoiseReductionMethod { get; set; } = "Gaussian";
    }
}
namespace Anomaly_Detector.Models
{
    /// <summary>
    /// Represents a PLC endpoint registered in the application.
    /// </summary>
    public class PLCEndpoint
    {
        /// <summary>
        /// Gets or sets the name or identifier of the endpoint.
        /// </summary>
        public string Name { get; set; } = string.Empty;

        /// <summary>
        /// Gets or sets the register address for the endpoint.
        /// </summary>
        public ushort RegisterAddress { get; set; }
    }
}
namespace Anomaly_Detector.Models
{
    /// <summary>
    /// Represents the configuration model for a PLC connection.
    /// </summary>
    public class PLCModel
    {
        /// <summary>
        /// Gets or sets the IP address of the PLC.
        /// </summary>
        public string IPAddress { get; set; } = string.Empty;

        /// <summary>
        /// Gets or sets the port number to connect (usually 502 for Modbus TCP).
        /// </summary>
        public int Port { get; set; }

        /// <summary>
        /// Gets or sets the Unit ID of the PLC on the Modbus network.
        /// </summary>
        public int UnitID { get; set; }

        /// <summary>
        /// Gets or sets the description for the PLC.
        /// </summary>
        public string Description { get; set; } = string.Empty;
    }
}
namespace Anomaly_Detector.Models
{
    /// <summary>
    /// Represents a single step in the image preprocessing pipeline.
    /// </summary>
    public class PreprocessingStep
    {
        /// <summary>
        /// Gets or sets the name of the preprocessing step.
        /// </summary>
        public string StepName { get; set; } = string.Empty;

        /// <summary>
        /// Gets or sets the parameters associated with this step.
        /// </summary>
        public string Parameters { get; set; } = string.Empty;

        /// <summary>
        /// Gets or sets the order index for sorting steps.
        /// </summary>
        public int Order { get; set; }
    }
}
using System;
using Emgu.CV;
using Emgu.CV.Structure;

namespace Anomaly_Detector.Services
{
    /// <summary>
    /// Provides methods to manage a camera connection and retrieve frames using Emgu.CV.
    /// </summary>
    public class CameraService : IDisposable
    {
        private VideoCapture? _capture;

        /// <summary>
        /// Initializes a new instance of the <see cref="CameraService"/> class.
        /// Connects to the specified camera by index (default is 0).
        /// </summary>
        /// <param name="cameraIndex">The index of the camera to connect to. Default is 0.</param>
        public CameraService(int cameraIndex = 0)
        {
            try
            {
                _capture = new VideoCapture(cameraIndex);
                if (!_capture.IsOpened)
                {
                    throw new Exception("Unable to open the camera.");
                }
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Error initializing camera: {ex.Message}");
            }
        }

        /// <summary>
        /// Captures and returns the current frame from the camera.
        /// </summary>
        /// <returns>
        /// An <see cref="Image{Bgr, byte}"/> representing the current frame,
        /// or <c>null</c> if the frame could not be captured.
        /// </returns>
        public Image<Bgr, byte>? GetCurrentFrame()
        {
            if (_capture == null)
            {
                Console.WriteLine("Camera is not initialized.");
                return null;
            }

            try
            {
                var frameMat = _capture.QueryFrame();
                if (frameMat != null)
                {
                    return frameMat.ToImage<Bgr, byte>();
                }
                return null;
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Error capturing frame: {ex.Message}");
                return null;
            }
        }

        /// <summary>
        /// Releases the camera resources.
        /// </summary>
        public void Release()
        {
            if (_capture != null)
            {
                _capture.Dispose();
                _capture = null;
            }
        }

        /// <summary>
        /// Releases all resources used by the <see cref="CameraService"/>.
        /// </summary>
        public void Dispose()
        {
            Release();
        }
    }
}
using System;
using Emgu.CV;
using Emgu.CV.CvEnum;
using Emgu.CV.Structure;
using System.Drawing;

namespace Anomaly_Detector.Services
{
    /// <summary>
    /// Provides methods for comparing two images and highlighting their differences.
    /// </summary>
    public static class ImageComparison
    {
        /// <summary>
        /// Computes the absolute difference between two images.
        /// The images must be in Bgr format and have the same dimensions.
        /// </summary>
        /// <param name="image1">The first input image in Bgr format.</param>
        /// <param name="image2">The second input image in Bgr format.</param>
        /// <returns>An image representing the absolute difference between the two input images.</returns>
        /// <exception cref="ArgumentNullException">Thrown if either image is null.</exception>
        /// <exception cref="ArgumentException">Thrown if the images have different sizes.</exception>
        public static Image<Bgr, byte> ComputeAbsoluteDifference(Image<Bgr, byte> image1, Image<Bgr, byte> image2)
        {
            if (image1 == null)
                throw new ArgumentNullException(nameof(image1));
            if (image2 == null)
                throw new ArgumentNullException(nameof(image2));
            if (image1.Size != image2.Size)
                throw new ArgumentException("Images must be of the same size.");

            return image1.AbsDiff(image2);
        }

        /// <summary>
        /// Computes the mean squared error (MSE) between two images.
        /// The images must be in Bgr format and have the same dimensions.
        /// </summary>
        /// <param name="image1">The first input image in Bgr format.</param>
        /// <param name="image2">The second input image in Bgr format.</param>
        /// <returns>The mean squared error as a double value.</returns>
        /// <exception cref="ArgumentNullException">Thrown if either image is null.</exception>
        /// <exception cref="ArgumentException">Thrown if the images have different sizes.</exception>
        public static double ComputeMeanSquaredError(Image<Bgr, byte> image1, Image<Bgr, byte> image2)
        {
            if (image1 == null)
                throw new ArgumentNullException(nameof(image1));
            if (image2 == null)
                throw new ArgumentNullException(nameof(image2));
            if (image1.Size != image2.Size)
                throw new ArgumentException("Images must be of the same size.");

            // Get the absolute difference image and convert it to grayscale.
            var diffImage = image1.AbsDiff(image2);
            var grayDiff = diffImage.Convert<Gray, byte>();

            double sumSquared = 0;
            int totalPixels = grayDiff.Width * grayDiff.Height;

            // Iterate over each pixel to accumulate the squared differences.
            for (int y = 0; y < grayDiff.Height; y++)
            {
                for (int x = 0; x < grayDiff.Width; x++)
                {
                    byte pixelValue = grayDiff.Data[y, x, 0];
                    sumSquared += pixelValue * pixelValue;
                }
            }
            return sumSquared / totalPixels;
        }

        /// <summary>
        /// Highlights differences between two images by overlaying red on regions where the absolute difference exceeds a threshold.
        /// </summary>
        /// <param name="image1">The first input image in Bgr format (this image will be used as the base).</param>
        /// <param name="image2">The second input image in Bgr format.</param>
        /// <param name="threshold">A threshold value for determining significant differences (default is 30).</param>
        /// <returns>An image with significant differences highlighted in red.</returns>
        /// <exception cref="ArgumentNullException">Thrown if either image is null.</exception>
        /// <exception cref="ArgumentException">Thrown if the images have different sizes.</exception>
        public static Image<Bgr, byte> HighlightDifferences(Image<Bgr, byte> image1, Image<Bgr, byte> image2, double threshold = 30)
        {
            // Validate input images
            if (image1 == null)
                throw new ArgumentNullException(nameof(image1), "Input image 1 cannot be null.");
            if (image2 == null)
                throw new ArgumentNullException(nameof(image2), "Input image 2 cannot be null.");
            if (image1.Size != image2.Size)
                throw new ArgumentException("Images must be of the same size.");

            try
            {
                // Step 1: Compute the absolute difference between the two images
                var diffImage = image1.AbsDiff(image2);

                // Step 2: Convert the difference image to grayscale
                var grayDiff = diffImage.Convert<Gray, byte>();

                // Step 3: Create a binary mask where differences exceed the threshold
                var mask = new Image<Gray, byte>(grayDiff.Size);
                CvInvoke.Threshold(grayDiff, mask, threshold, 255, ThresholdType.Binary);

                // Step 4: Create a copy of the original image to highlight differences
                var highlightedImage = image1.Copy();

                // Step 5: Create a red mask for highlighting
                var redMask = new Image<Bgr, byte>(highlightedImage.Size);
                redMask.SetValue(new Bgr(0, 0, 255)); // Red color (B=0, G=0, R=255)

                // Step 6: Apply the red mask to the highlighted image where differences are significant
                CvInvoke.BitwiseAnd(redMask, redMask, highlightedImage, mask);

                return highlightedImage;
            }
            catch (Exception ex)
            {
                // Log the error and rethrow if necessary
                Console.WriteLine($"Error highlighting differences: {ex.Message}");
                throw;
            }
        }
    }
}
using System;
using Emgu.CV;
using Emgu.CV.CvEnum;
using Emgu.CV.Structure;
using System.Drawing;

namespace Anomaly_Detector.Services
{
    /// <summary>
    /// Provides various image preprocessing functionalities such as converting to grayscale,
    /// noise filtering, light balancing, contrast enhancement, resizing, and geometric transformations.
    /// </summary>
    public static class ImagePreprocessing
    {
        /// <summary>
        /// Converts a BGR image to a grayscale image.
        /// </summary>
        /// <param name="inputImage">The input image in Bgr format.</param>
        /// <returns>An image converted to grayscale.</returns>
        /// <exception cref="ArgumentNullException">Thrown if inputImage is null.</exception>
        public static Image<Gray, byte> ConvertToGrayscale(Image<Bgr, byte> inputImage)
        {
            if (inputImage == null)
                throw new ArgumentNullException(nameof(inputImage), "Input image cannot be null.");
            return inputImage.Convert<Gray, byte>();
        }

        /// <summary>
        /// Resizes the given BGR image to the specified width and height.
        /// </summary>
        /// <param name="inputImage">The input image in Bgr format.</param>
        /// <param name="width">The desired width.</param>
        /// <param name="height">The desired height.</param>
        /// <returns>The resized image.</returns>
        /// <exception cref="ArgumentNullException">Thrown if inputImage is null.</exception>
        public static Image<Bgr, byte> ResizeImage(Image<Bgr, byte> inputImage, int width, int height)
        {
            if (inputImage == null)
                throw new ArgumentNullException(nameof(inputImage), "Input image cannot be null.");
            return inputImage.Resize(width, height, Inter.Linear);
        }

        /// <summary>
        /// Applies a Gaussian blur to the input BGR image.
        /// </summary>
        /// <param name="inputImage">The input image in Bgr format.</param>
        /// <param name="kernelSize">The size of the Gaussian kernel (must be an odd number, e.g., 3, 5, 7).</param>
        /// <returns>The blurred image.</returns>
        /// <exception cref="ArgumentNullException">Thrown if inputImage is null.</exception>
        /// <exception cref="ArgumentException">Thrown if kernelSize is not an odd number.</exception>
        public static Image<Bgr, byte> ApplyGaussianBlur(Image<Bgr, byte> inputImage, int kernelSize = 5)
        {
            if (inputImage == null)
                throw new ArgumentNullException(nameof(inputImage), "Input image cannot be null.");
            if (kernelSize % 2 == 0)
                throw new ArgumentException("Kernel size must be an odd number.", nameof(kernelSize));
            return inputImage.SmoothGaussian(kernelSize);
        }

        /// <summary>
        /// Applies a binary threshold to a grayscale image.
        /// </summary>
        /// <param name="inputImage">The input image in grayscale.</param>
        /// <param name="thresholdValue">The threshold value.</param>
        /// <returns>The binary image resulting from thresholding.</returns>
        /// <exception cref="ArgumentNullException">Thrown if inputImage is null.</exception>
        public static Image<Gray, byte> ApplyThreshold(Image<Gray, byte> inputImage, double thresholdValue)
        {
            if (inputImage == null)
                throw new ArgumentNullException(nameof(inputImage), "Input image cannot be null.");
            Image<Gray, byte> binaryImage = inputImage.CopyBlank();
            CvInvoke.Threshold(inputImage, binaryImage, thresholdValue, 255, ThresholdType.Binary);
            return binaryImage;
        }

        /// <summary>
        /// Applies a median filter to reduce noise in a BGR image.
        /// </summary>
        /// <param name="inputImage">The input image in Bgr format.</param>
        /// <param name="kernelSize">The size of the median filter kernel (must be an odd number, e.g., 3, 5, 7).</param>
        /// <returns>The denoised image.</returns>
        /// <exception cref="ArgumentNullException">Thrown if inputImage is null.</exception>
        /// <exception cref="ArgumentException">Thrown if kernelSize is not an odd number.</exception>
        public static Image<Bgr, byte> ApplyMedianFilter(Image<Bgr, byte> inputImage, int kernelSize = 3)
        {
            if (inputImage == null)
                throw new ArgumentNullException(nameof(inputImage), "Input image cannot be null.");
            if (kernelSize % 2 == 0)
                throw new ArgumentException("Kernel size must be an odd number.", nameof(kernelSize));
            Image<Bgr, byte> filteredImage = inputImage.CopyBlank();
            CvInvoke.MedianBlur(inputImage, filteredImage, kernelSize);
            return filteredImage;
        }

        /// <summary>
        /// Applies histogram equalization to a grayscale image to balance lighting.
        /// </summary>
        /// <param name="inputImage">The input grayscale image.</param>
        /// <returns>The image after histogram equalization.</returns>
        /// <exception cref="ArgumentNullException">Thrown if inputImage is null.</exception>
        public static Image<Gray, byte> EqualizeHistogram(Image<Gray, byte> inputImage)
        {
            if (inputImage == null)
                throw new ArgumentNullException(nameof(inputImage), "Input image cannot be null.");
            Image<Gray, byte> equalizedImage = inputImage.CopyBlank();
            CvInvoke.EqualizeHist(inputImage, equalizedImage);
            return equalizedImage;
        }

        // Replace the EnhanceContrastCLAHE method with the following code
        /// <summary>
        /// Enhances the contrast of a grayscale image using CLAHE (Contrast Limited Adaptive Histogram Equalization).
        /// </summary>
        /// <param name="inputImage">The input grayscale image.</param>
        /// <param name="clipLimit">The threshold for contrast limiting (default is 2.0).</param>
        /// <param name="tileGridSize">The size of the grid for the histogram equalization (default is 8x8).</param>
        /// <returns>The contrast-enhanced image.</returns>
        /// <exception cref="ArgumentNullException">Thrown if inputImage is null.</exception>
        //public static Image<Gray, byte> EnhanceContrastCLAHE(Image<Gray, byte> inputImage, double clipLimit = 2.0, Size tileGridSize = default)
        //{
        //    if (inputImage == null)
        //        throw new ArgumentNullException(nameof(inputImage), "Input image cannot be null.");

        //    if (tileGridSize == default)
        //        tileGridSize = new Size(8, 8);

        //    using (var clahe = new CudaCLAHE(clipLimit, tileGridSize))
        //    {
        //        Image<Gray, byte> result = inputImage.CopyBlank();
        //        clahe.Apply(inputImage, result);
        //        return result;
        //    }
        //}

        /// <summary>
        /// Adjusts the brightness of a BGR image by adding a constant value to each pixel.
        /// </summary>
        /// <param name="inputImage">The input image in Bgr format.</param>
        /// <param name="brightness">The brightness adjustment value (positive to increase brightness, negative to decrease).</param>
        /// <returns>The brightness-adjusted image.</returns>
        /// <exception cref="ArgumentNullException">Thrown if inputImage is null.</exception>
        public static Image<Bgr, byte> AdjustBrightness(Image<Bgr, byte> inputImage, int brightness)
        {
            if (inputImage == null)
                throw new ArgumentNullException(nameof(inputImage), "Input image cannot be null.");

            // Create a new image and add brightness using AddWeighted (alpha=1.0, beta=0.0, gamma=brightness)
            Image<Bgr, byte> adjustedImage = inputImage.Copy();
            CvInvoke.AddWeighted(inputImage, 1.0, adjustedImage, 0.0, brightness, adjustedImage);
            return adjustedImage;
        }

        /// <summary>
        /// Rotates a BGR image by a specified angle.
        /// </summary>
        /// <param name="inputImage">The input image in Bgr format.</param>
        /// <param name="angle">The rotation angle in degrees.</param>
        /// <returns>The rotated image.</returns>
        /// <exception cref="ArgumentNullException">Thrown if inputImage is null.</exception>
        public static Image<Bgr, byte> RotateImage(Image<Bgr, byte> inputImage, double angle)
        {
            if (inputImage == null)
                throw new ArgumentNullException(nameof(inputImage), "Input image cannot be null.");

            PointF center = new PointF(inputImage.Width / 2f, inputImage.Height / 2f);
            using (var rotationMatrix = new Emgu.CV.Matrix<double>(2, 3))
            {
                CvInvoke.GetRotationMatrix2D(center, angle, 1.0, rotationMatrix);
                Image<Bgr, byte> rotated = inputImage.CopyBlank();
                CvInvoke.WarpAffine(inputImage, rotated, rotationMatrix, inputImage.Size, Inter.Linear, Warp.Default, BorderType.Constant, new MCvScalar());
                return rotated;
            }
        }

        /// <summary>
        /// Applies an affine transformation to a BGR image using the specified transformation matrix.
        /// </summary>
        /// <param name="inputImage">The input image in Bgr format.</param>
        /// <param name="affineMatrix">A 2x3 affine transformation matrix.</param>
        /// <returns>The transformed image.</returns>
        /// <exception cref="ArgumentNullException">Thrown if inputImage or affineMatrix is null.</exception>
        public static Image<Bgr, byte> ApplyAffineTransformation(Image<Bgr, byte> inputImage, Emgu.CV.Matrix<double> affineMatrix)
        {
            if (inputImage == null)
                throw new ArgumentNullException(nameof(inputImage), "Input image cannot be null.");
            if (affineMatrix == null)
                throw new ArgumentNullException(nameof(affineMatrix), "Affine transformation matrix cannot be null.");

            Image<Bgr, byte> transformed = inputImage.CopyBlank();
            CvInvoke.WarpAffine(inputImage, transformed, affineMatrix, inputImage.Size, Inter.Linear, Warp.Default, BorderType.Constant, new MCvScalar());
            return transformed;
        }
    }
}
using System;
using System.IO;
using System.Xml;
using Newtonsoft.Json;

namespace Anomaly_Detector.Services
{
    /// <summary>
    /// Provides methods for saving and loading data in JSON format.
    /// </summary>
    /// <typeparam name="T">The type of data to be serialized and deserialized.</typeparam>
    public class JsonDatabaseService<T> where T : class
    {
        private readonly string _filePath;

        /// <summary>
        /// Initializes a new instance of the <see cref="JsonDatabaseService{T}"/> class.
        /// </summary>
        /// <param name="filePath">The file path where the JSON data will be stored.</param>
        public JsonDatabaseService(string filePath)
        {
            _filePath = filePath;
        }

        /// <summary>
        /// Saves the specified data to a JSON file.
        /// </summary>
        /// <param name="data">The data to be saved.</param>
        public void SaveData(T data)
        {
            try
            {
                string jsonData = JsonConvert.SerializeObject(data, Newtonsoft.Json.Formatting.Indented);
                File.WriteAllText(_filePath, jsonData);
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Error saving JSON data: {ex.Message}");
            }
        }

        /// <summary>
        /// Loads data from a JSON file.
        /// </summary>
        /// <returns>
        /// The deserialized data, or null if the file does not exist or an error occurs.
        /// </returns>
        public T? LoadData()
        {
            try
            {
                if (File.Exists(_filePath))
                {
                    string jsonData = File.ReadAllText(_filePath);
                    return JsonConvert.DeserializeObject<T>(jsonData);
                }
                return null;
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Error loading JSON data: {ex.Message}");
                return null;
            }
        }
    }
}
using System;
using System.Net.Sockets;
using Modbus.Device;  // Requires NModbus4 NuGet package
using Anomaly_Detector.Models;

namespace Anomaly_Detector.Services
{
    /// <summary>
    /// Provides methods for connecting to and communicating with a PLC using Modbus TCP.
    /// </summary>
    public class ModbusService : IDisposable
    {
        // Mark fields as nullable to resolve non-nullable warnings.
        private TcpClient? _tcpClient;
        private IModbusMaster? _modbusMaster;
        private readonly PLCModel _plcModel;

        /// <summary>
        /// Initializes a new instance of the <see cref="ModbusService"/> class with the specified PLC configuration.
        /// </summary>
        /// <param name="plcModel">The PLC configuration model.</param>
        public ModbusService(PLCModel plcModel)
        {
            _plcModel = plcModel;
            Connect();
        }

        /// <summary>
        /// Establishes a connection to the PLC using the provided configuration.
        /// </summary>
        private void Connect()
        {
            try
            {
                _tcpClient = new TcpClient(_plcModel.IPAddress, _plcModel.Port);
                // Create a Modbus master instance using the TCP connection.
                _modbusMaster = ModbusIpMaster.CreateIp(_tcpClient);
                Console.WriteLine("Connected to PLC successfully!");
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Error connecting to PLC: {ex.Message}");
                // Additional logging or error handling can be added here.
            }
        }

        /// <summary>
        /// Reads a range of holding registers from the PLC.
        /// </summary>
        /// <param name="startAddress">The starting register address.</param>
        /// <param name="numberOfPoints">The number of registers to read.</param>
        /// <returns>An array of unsigned shorts containing the register values, or null if an error occurs.</returns>
        public ushort[]? ReadHoldingRegisters(ushort startAddress, ushort numberOfPoints)
        {
            if (_modbusMaster == null)
            {
                Console.WriteLine("Modbus master is not initialized.");
                return null;
            }

            try
            {
                // Cast the UnitID from int to byte
                return _modbusMaster.ReadHoldingRegisters((byte)_plcModel.UnitID, startAddress, numberOfPoints);
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Error reading registers: {ex.Message}");
                return null;
            }
        }

        /// <summary>
        /// Writes a single value to a specific register on the PLC.
        /// </summary>
        /// <param name="registerAddress">The register address to write to.</param>
        /// <param name="value">The value to write.</param>
        public void WriteSingleRegister(ushort registerAddress, ushort value)
        {
            if (_modbusMaster == null)
            {
                Console.WriteLine("Modbus master is not initialized.");
                return;
            }

            try
            {
                // Cast UnitID from int to byte
                _modbusMaster.WriteSingleRegister((byte)_plcModel.UnitID, registerAddress, value);
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Error writing to register: {ex.Message}");
            }
        }

        /// <summary>
        /// Disconnects from the PLC and releases the TCP connection.
        /// </summary>
        public void Disconnect()
        {
            if (_tcpClient != null)
            {
                _tcpClient.Close();
                _tcpClient = null;
            }
            Console.WriteLine("PLC connection disconnected.");
        }

        /// <summary>
        /// Releases all resources used by the <see cref="ModbusService"/>.
        /// </summary>
        public void Dispose()
        {
            Disconnect();
            _modbusMaster?.Dispose();
        }
    }
}
using System.ComponentModel;
using System.Runtime.CompilerServices;

namespace Anomaly_Detector.ViewModels
{
    /// <summary>
    /// A base class for ViewModels that implements INotifyPropertyChanged to enable property change notifications.
    /// </summary>
    public class BaseViewModel : INotifyPropertyChanged
    {
        /// <summary>
        /// Occurs when a property value changes.
        /// </summary>
        public event PropertyChangedEventHandler? PropertyChanged;

        /// <summary>
        /// Raises the PropertyChanged event.
        /// </summary>
        /// <param name="propertyName">The name of the property that changed. Automatically provided by the compiler if not specified.</param>
        protected void OnPropertyChanged([CallerMemberName] string propertyName = null)
        {
            PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName));
        }
    }
}
using Anomaly_Detector.Models;
using Anomaly_Detector.Services;
using Emgu.CV;

using System;
using System.Collections.ObjectModel;
using System.Windows.Input;
using System.Windows.Media.Imaging;

namespace Anomaly_Detector.ViewModels
{
    /// <summary>
    /// The main view model for the application, exposing the settings and commands for image capture and comparison.
    /// </summary>
    public class MonitoringViewModel : BaseViewModel
    {
        public ObservableCollection<CameraModel> Cameras { get; set; }

        public ICommand CaptureImageCommand { get; set; }
        public ICommand CompareImagesCommand { get; set; }

        public MonitoringViewModel()
        {
            Cameras = LoadCameras();
            CaptureImageCommand = new RelayCommand(CaptureImage);
            CompareImagesCommand = new RelayCommand(CompareImages);
        }

        private ObservableCollection<CameraModel> LoadCameras()
        {
            var jsonDatabaseService = new JsonDatabaseService<ApplicationSettings>("settings.json");
            var settings = jsonDatabaseService.LoadData();
            return settings?.Cameras ?? new ObservableCollection<CameraModel>();
        }

        private void CaptureImage(object parameter)
        {
            if (parameter is CameraModel cam)
            {
                using (var cameraService = new CameraService(cam.CameraIndex))
                {
                    var frame = cameraService.GetCurrentFrame();
                    if (frame != null)
                    {
                        //cam.TargetImage = frame.ToBitmapSource();
                    }
                }
            }
        }

        private void CompareImages(object parameter)
        {
            if (parameter is CameraModel cam)
            {
                if (cam.TargetImage != null && !string.IsNullOrEmpty(cam.StandardImagePath))
                {
                    //var comparisonResult = ImageComparison.ComputeMeanSquaredError(
                    //    cam.StandardImage, cam.TargetImage);

                    //cam.ComparisonMessage = comparisonResult < cam.Threshold ?
                    //    "Images match" : "Images differ";
                }
            }
        }
    }

}
using System;
using System.Windows.Input;

namespace Anomaly_Detector.ViewModels
{
    /// <summary>
    /// A command whose sole purpose is to relay its functionality to other objects by invoking delegates.
    /// </summary>
    public class RelayCommand : ICommand
    {
        private readonly Action<object> _execute;
        private readonly Predicate<object>? _canExecute;

        /// <summary>
        /// Occurs when changes occur that affect whether or not the command should execute.
        /// </summary>
        public event EventHandler? CanExecuteChanged;

        /// <summary>
        /// Initializes a new instance of the RelayCommand class.
        /// </summary>
        /// <param name="execute">The execution logic.</param>
        /// <param name="canExecute">The execution status logic. Optional.</param>
        public RelayCommand(Action<object> execute, Predicate<object>? canExecute = null)
        {
            _execute = execute ?? throw new ArgumentNullException(nameof(execute));
            _canExecute = canExecute;
        }

        /// <summary>
        /// Determines whether this command can execute in its current state.
        /// </summary>
        /// <param name="parameter">Data used by the command. If the command does not require data, this object can be set to null.</param>
        /// <returns>true if this command can be executed; otherwise, false.</returns>
        public bool CanExecute(object? parameter)
        {
            return _canExecute == null || _canExecute(parameter);
        }

        /// <summary>
        /// Executes the command.
        /// </summary>
        /// <param name="parameter">Data used by the command.</param>
        public void Execute(object? parameter)
        {
            _execute(parameter);
        }

        /// <summary>
        /// Raises the CanExecuteChanged event.
        /// </summary>
        public void RaiseCanExecuteChanged()
        {
            CanExecuteChanged?.Invoke(this, EventArgs.Empty);
        }
    }
}
using Anomaly_Detector.Models;
using Anomaly_Detector.Services;
using Anomaly_Detector.Views;
using Emgu.CV;
using Emgu.CV.Structure;
using System;
using System.ComponentModel;
using System.IO;
using System.Linq;
using System.Windows;
using System.Windows.Input;
using System.Windows.Media.Imaging;

namespace Anomaly_Detector.ViewModels
{
    public class SettingsViewModel : BaseViewModel
    {
        public ApplicationSettings ApplicationSettings { get; set; }

        // Commands for managing cameras, PLC endpoints, and preprocessing steps.
        public ICommand AddCameraCommand { get; set; }
        public ICommand RegisterPLCEndpointsCommand { get; set; }
        public ICommand AddPreprocessingStepCommand { get; set; }
        public ICommand RemovePreprocessingStepCommand { get; set; }
        public ICommand SortPreprocessingStepsCommand { get; set; }

        // Commands for connectivity and image capture.
        public ICommand CheckCameraConnectionCommand { get; set; }
        public ICommand CheckPLCConnectionCommand { get; set; }
        public ICommand CaptureStandardImageCommand { get; set; }
        public ICommand SaveSettingsCommand { get; set; }
        public ICommand SaveCapturedImageCommand { get; set; }
        public ICommand DeleteCapturedImageCommand { get; set; }

        private string? _capturedImagePath;

        // Property to indicate connectivity.
        private bool _cameraConnected;
        public bool CameraConnected
        {
            get => _cameraConnected;
            set { _cameraConnected = value; OnPropertyChanged(); }
        }

        private bool _plcConnected;
        public bool PLCConnected
        {
            get => _plcConnected;
            set { _plcConnected = value; OnPropertyChanged(); }
        }

        // Property to hold the captured image for display.
        private BitmapSource? _capturedImage; // Make nullable
        public BitmapSource? CapturedImage
        {
            get => _capturedImage;
            set { _capturedImage = value; OnPropertyChanged(); }
        }


        // Property to control visibility of the Capture Standard Image button.
        private bool _showCaptureButton;
        public bool ShowCaptureButton
        {
            get => _showCaptureButton;
            set { _showCaptureButton = value; OnPropertyChanged(); }
        }

        // Initializes a new instance of the SettingsViewModel class.
        public SettingsViewModel()
        {
            ApplicationSettings = LoadSettings();  // Load saved settings

            // Other initialization code...
            ApplicationSettings.Cameras.CollectionChanged += Cameras_CollectionChanged;

            // Initialize commands
            AddCameraCommand = new RelayCommand(AddCamera);
            RegisterPLCEndpointsCommand = new RelayCommand(RegisterPLCEndpoints);
            AddPreprocessingStepCommand = new RelayCommand(AddPreprocessingStep);
            RemovePreprocessingStepCommand = new RelayCommand(RemovePreprocessingStep);
            SortPreprocessingStepsCommand = new RelayCommand(SortPreprocessingSteps);
            CheckCameraConnectionCommand = new RelayCommand(CheckCameraConnection);
            CheckPLCConnectionCommand = new RelayCommand(CheckPLCConnection);
            SaveSettingsCommand = new RelayCommand(SaveSettings);
            // Initialize Commands
            CaptureStandardImageCommand = new RelayCommand(CaptureStandardImage);
            SaveCapturedImageCommand = new RelayCommand(SaveCapturedImage);
            DeleteCapturedImageCommand = new RelayCommand(DeleteCapturedImage);


        }

        private ApplicationSettings LoadSettings()
        {
            var jsonService = new JsonDatabaseService<ApplicationSettings>("settings.json");
            return jsonService.LoadData() ?? new ApplicationSettings();  // Return default if no saved settings found
        }

        // Handles changes in the camera collection.
        private void Cameras_CollectionChanged(object? sender, System.Collections.Specialized.NotifyCollectionChangedEventArgs e)
        {
            if (e.NewItems != null)
            {
                foreach (CameraModel cam in e.NewItems)
                {
                    if (cam is INotifyPropertyChanged notifier)
                    {
                        notifier.PropertyChanged += (s, ev) =>
                        {
                            //if (ApplicationSettings.Cameras.Count > 0 && ApplicationSettings.Cameras[0] == cam)
                                //CheckCameraConnection(null);
                        };
                    }
                }
            }
        }

        private void OpenCamera(CameraModel camera)
        {
            if (camera != null)
            {
                // M? c?a s? Camera (B?n có th? t?o m?t c?a s? m?i ho?c x? lý thêm t?i dây)
                CameraWindow cameraWindow = new CameraWindow(camera);
                cameraWindow.Show();
            }
        }

        // Adds a new camera to the list.
        private void AddCamera(object parameter)
        {
            var newCamera = new CameraModel
            {
                CameraIndex = ApplicationSettings.Cameras.Count,
                Description = "New Camera"
            };
            ApplicationSettings.Cameras.Add(newCamera);
            //if (ApplicationSettings.Cameras.Count == 1)
            //    CheckCameraConnection(null);
        }

        // Registers new PLC endpoints.
        private void RegisterPLCEndpoints(object parameter)
        {
            ApplicationSettings.PLCEndpoints.Add(new PLCEndpoint
            {
                Name = "Endpoint " + (ApplicationSettings.PLCEndpoints.Count + 1),
                RegisterAddress = 100
            });
        }

        // Adds a preprocessing step.
        private void AddPreprocessingStep(object parameter)
        {
            int order = ApplicationSettings.PreprocessingSteps.Count + 1;
            ApplicationSettings.PreprocessingSteps.Add(new PreprocessingStep
            {
                Order = order,
                StepName = "New Step",
                Parameters = ""
            });
        }

        // Removes the last preprocessing step.
        private void RemovePreprocessingStep(object parameter)
        {
            if (ApplicationSettings.PreprocessingSteps.Count > 0)
            {
                ApplicationSettings.PreprocessingSteps.RemoveAt(ApplicationSettings.PreprocessingSteps.Count - 1);
            }
        }

        // Sorts preprocessing steps by their order.
        private void SortPreprocessingSteps(object parameter)
        {
            var sorted = new System.Collections.Generic.List<PreprocessingStep>(ApplicationSettings.PreprocessingSteps);
            sorted.Sort((x, y) => x.Order.CompareTo(y.Order));
            ApplicationSettings.PreprocessingSteps.Clear();
            foreach (var step in sorted)
            {
                ApplicationSettings.PreprocessingSteps.Add(step);
            }
        }

        // Checks the connectivity of the first configured camera.
        // Ki?m tra k?t n?i camera b?t d?ng b?
        private async void CheckCameraConnection(object parameter)
        {
            foreach (var camera in ApplicationSettings.Cameras)
            {
                try
                {
                    using (var cameraService = new CameraService(camera.CameraIndex))
                    {
                        var frame = await Task.Run(() => cameraService.GetCurrentFrame());
                        // C?p nh?t UI qua Dispatcher
                        Application.Current.Dispatcher.Invoke(() =>
                        {
                            camera.IsConnected = (frame != null);
                            camera.ConnectionColor = (frame != null) ? "Green" : "Gray";
                        });
                    }
                }
                catch (Exception ex)
                {
                    MessageBox.Show($"L?i camera {camera.CameraIndex}: {ex.Message}");
                }
            }
        }


        // Checks the connectivity of the PLC by attempting to read a register.
        private void CheckPLCConnection(object parameter)
        {
            try
            {
                using (var modbusService = new ModbusService(ApplicationSettings.PLCConfiguration))
                {
                    var registers = modbusService.ReadHoldingRegisters(0, 1);
                    PLCConnected = (registers != null);
                }
            }
            catch (Exception ex)
            {
                PLCConnected = false;
                Console.WriteLine($"PLC connection error: {ex.Message}");
            }
        }

        // Saves the current application settings to a JSON file.
        private void SaveSettings(object parameter)
        {
            try
            {
                var jsonService = new JsonDatabaseService<ApplicationSettings>("settings.json");
                jsonService.SaveData(ApplicationSettings);
            }
            catch (Exception ex)
            {
                MessageBox.Show($"Error saving settings: {ex.Message}");
            }
        }
        private async void CaptureStandardImage(object parameter)
        {
            // Get the selected camera from the parameter
            if (parameter is CameraModel selectedCamera)
            {
                if (ApplicationSettings.ImageStoragePath == null || !Directory.Exists(ApplicationSettings.ImageStoragePath))
                {
                    MessageBox.Show("Invalid Image Storage Path");
                    return;
                }

                string directoryPath = Path.Combine(ApplicationSettings.ImageStoragePath, "Standard");
                Directory.CreateDirectory(directoryPath); // Ensure the directory exists

                // Capture image from the selected camera
                var cameraService = new CameraService(selectedCamera.CameraIndex);  // Use CameraIndex from selected camera
                var frame = await Task.Run(() => cameraService.GetCurrentFrame());
                if (frame != null)
                {
                    // Convert captured frame to BitmapSource
                    CapturedImage = frame.ToBitmapSource();

                    // Save the captured image
                    string imagePath = Path.Combine(directoryPath, "StandardImage.jpg");
                    frame.Save(imagePath);  // Save the image to disk

                    // Update the StandardImagePath for the selected camera
                    selectedCamera.StandardImagePath = imagePath;
                    MessageBox.Show("Image captured and saved successfully.");
                }
            }
        }

        private void SaveCapturedImage(object parameter)
        {
            if (parameter is CameraModel selectedCamera && !string.IsNullOrEmpty(selectedCamera.StandardImagePath))
            {
                // Update the StandardImagePath for the selected camera
                selectedCamera.StandardImagePath = selectedCamera.StandardImagePath;
                MessageBox.Show("Image path updated successfully.");
            }
            else
            {
                MessageBox.Show("No image captured or path not set.");
            }
        }
        private void DeleteCapturedImage(object parameter)
        {
            if (parameter is CameraModel selectedCamera && !string.IsNullOrEmpty(selectedCamera.StandardImagePath))
            {
                if (File.Exists(selectedCamera.StandardImagePath))
                {
                    File.Delete(selectedCamera.StandardImagePath);
                    selectedCamera.StandardImagePath = string.Empty; // Clear the path after deletion
                    MessageBox.Show("Image deleted.");
                    CapturedImage = null; // Clear the displayed image
                }
                else
                {
                    MessageBox.Show("No image to delete.");
                }
            }
            else
            {
                MessageBox.Show("No image captured.");
            }
        }

    }
}
<Window x:Class="Anomaly_Detector.Views.SettingsWindow"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        xmlns:vm="clr-namespace:Anomaly_Detector.ViewModels"
        Title="Settings" Height="700" Width="900">

    <Window.DataContext>
        <vm:SettingsViewModel/>
    </Window.DataContext>

    <DockPanel>
        <TabControl DockPanel.Dock="Top">
            <TabItem Header="Camera Settings">
                <Grid Margin="10">
                    <StackPanel>
                        <!-- Display Captured Image -->
                        <Image Name="CapturedImage" Width="300" Height="200" HorizontalAlignment="Center" Margin="10" />

                        <!-- Capture, Save, Delete Buttons -->
                        <StackPanel Orientation="Horizontal" HorizontalAlignment="Center" Margin="0,10,0,0">
                            <Button Content="Capture" Command="{Binding CaptureStandardImageCommand}" Width="100" Margin="5"/>
                            <Button Content="Save" Command="{Binding SaveCapturedImageCommand}" Width="100" Margin="5"/>
                            <Button Content="Delete" Command="{Binding DeleteCapturedImageCommand}" Width="100" Margin="5"/>
                        </StackPanel>
                    </StackPanel>
                </Grid>
            </TabItem>
        </TabControl>
    </DockPanel>
</Window>
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Controls;
using System.Windows.Data;
using System.Windows.Documents;
using System.Windows.Input;
using System.Windows.Media;
using System.Windows.Media.Imaging;
using System.Windows.Shapes;
using Anomaly_Detector.Models;

namespace Anomaly_Detector.Views
{
    /// <summary>
    /// Interaction logic for CameraWindow.xaml
    /// </summary>
    public partial class CameraWindow : Window
    {
        public CameraModel Camera { get; set; }

        public CameraWindow(CameraModel camera)
        {
            InitializeComponent();
            Camera = camera;
        }
    }

}
<Window x:Class="Anomaly_Detector.Views.MonitorWindow"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        xmlns:vm="clr-namespace:Anomaly_Detector.ViewModels"
        Title="MonitorWindow" Height="600" Width="1600">

    <Window.DataContext>
        <vm:MonitoringViewModel/>
    </Window.DataContext>

    <Grid>
        <!-- Hi?n th? danh sách Cameras theo chi?u ngang -->
        <ItemsControl ItemsSource="{Binding Cameras}" AlternationCount="2">

            <!-- Tùy ch?nh Panel d? hi?n th? t? trái sang ph?i -->
            <ItemsControl.ItemsPanel>
                <ItemsPanelTemplate>
                    <WrapPanel Orientation="Horizontal"/>
                </ItemsPanelTemplate>
            </ItemsControl.ItemsPanel>

            <ItemsControl.ItemTemplate>
                <DataTemplate>
                    <GroupBox Width="800" Height="600" Margin="10">
                        <GroupBox.Header>
                            <TextBlock Text="{Binding Description}" FontWeight="Bold" HorizontalAlignment="Center"/>
                        </GroupBox.Header>
                        <Grid Margin="10">
                            <Grid.RowDefinitions>
                                <RowDefinition Height="Auto"/>
                                <RowDefinition Height="*"/>
                                <RowDefinition Height="Auto"/>
                                <RowDefinition Height="*"/>
                            </Grid.RowDefinitions>

                            <Grid Grid.Row="1">
                                <Grid.ColumnDefinitions>
                                    <ColumnDefinition Width="*"/>
                                    <ColumnDefinition Width="*"/>
                                </Grid.ColumnDefinitions>

                                <!-- Standard Image -->
                                <GroupBox Header="Standard Image" Grid.Column="0" Margin="5">
                                    <StackPanel>
                                        <Image Stretch="Uniform" Height="150" Margin="0,5,0,5"
                                               Source="{Binding StandardImagePath}" />
                                    </StackPanel>
                                </GroupBox>

                                <!-- Target Image -->
                                <GroupBox Header="Target Image" Grid.Column="1" Margin="5">
                                    <Image Stretch="Uniform" Height="150" Margin="0,5,0,5"
                                           Source="{Binding TargetImage}" />
                                </GroupBox>
                            </Grid>

                            <!-- Threshold input and action buttons -->
                            <StackPanel Grid.Row="2" Orientation="Horizontal" HorizontalAlignment="Left" Margin="0,10,0,10">
                                <Button Content="Register Standard" Width="160" Margin="0,0,10,0"/>
                                <Label Content="Threshold:" VerticalAlignment="Center" Margin="0,0,5,0"/>
                                <TextBox Width="50" Margin="0,0,10,0"/>
                                <Button Content="Compare" Width="100"
                                        Command="{Binding DataContext.CompareImagesCommand, RelativeSource={RelativeSource AncestorType=Window}}" 
                                        CommandParameter="{Binding}" />
                            </StackPanel>

                            <!-- Results Table -->
                            <DataGrid Grid.Row="3" AutoGenerateColumns="False" CanUserAddRows="False" IsReadOnly="True">
                                <DataGrid.Columns>
                                    <DataGridTextColumn Header="Time" Width="120" Binding="{Binding Time}"/>
                                    <DataGridTextColumn Header="Title" Width="150" Binding="{Binding Name}"/>
                                    <DataGridTextColumn Header="File Name" Width="200" Binding="{Binding FileName}"/>
                                    <DataGridTextColumn Header="Score" Width="*" Binding="{Binding Score}"/>
                                    <DataGridTextColumn Header="Result" Width="100" Binding="{Binding Result}"/>
                                </DataGrid.Columns>
                            </DataGrid>
                        </Grid>
                    </GroupBox>
                </DataTemplate>
            </ItemsControl.ItemTemplate>
        </ItemsControl>
    </Grid>
</Window>
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Controls;
using System.Windows.Data;
using System.Windows.Documents;
using System.Windows.Input;
using System.Windows.Media;
using System.Windows.Media.Imaging;
using System.Windows.Shapes;

namespace Anomaly_Detector.Views
{
    /// <summary>
    /// Interaction logic for MonitorWindow.xaml
    /// </summary>
    public partial class MonitorWindow : Window
    {
        public MonitorWindow()
        {
            InitializeComponent();
        }
    }
}
<Window x:Class="Anomaly_Detector.Views.SettingsWindow"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        xmlns:vm="clr-namespace:Anomaly_Detector.ViewModels"
        Title="Settings" Height="700" Width="900">
    <Window.DataContext>
        <vm:SettingsViewModel/>
    </Window.DataContext>
    <DockPanel>
        <TabControl DockPanel.Dock="Top">
            <!-- Cameras Tab -->
            <TabItem Header="Cameras">
                <Grid Margin="10">
                    <StackPanel>
                        <DataGrid ItemsSource="{Binding ApplicationSettings.Cameras}" AutoGenerateColumns="False" Height="150"   MouseDoubleClick="CameraItem_DoubleClick">
                            <DataGrid.Resources>
                                <Style TargetType="DataGridRow">
                                    <Setter Property="Background" Value="{Binding ConnectionColor}"/>
                                </Style>
                            </DataGrid.Resources>
                            <DataGrid.Columns>
                                <DataGridTextColumn Header="Camera Index" Binding="{Binding CameraIndex}" Width="*"/>
                                <DataGridTextColumn Header="IP Address" Binding="{Binding IPAddress}" Width="*" IsReadOnly="True"/>
                                <DataGridTextColumn Header="Port" Binding="{Binding Port}" Width="*" IsReadOnly="True"/>
                                <DataGridTextColumn Header="Description" Binding="{Binding Description}" Width="*"/>
                                <DataGridTextColumn Header="Standard Image Path" Binding="{Binding StandardImagePath}" Width="2*"/>
                            </DataGrid.Columns>
                            
                        </DataGrid>
                        <StackPanel Orientation="Horizontal" Margin="0,10,0,0">
                            <Button Content="Add Camera" Command="{Binding AddCameraCommand}" Width="100" Margin="0,0,10,0"/>
                            <Button Content="Remove Camera" Width="100" Margin="0,0,10,0"/>
                            <Button Content="Check Camera" Command="{Binding CheckCameraConnectionCommand}" Width="100" Margin="0,0,10,0"/>
                        </StackPanel>

                        <!-- Display captured image -->
                    </StackPanel>
                </Grid>
            </TabItem>

            <!-- PLC Tab (unchanged) -->
            <TabItem Header="PLC">
                <Grid Margin="10">
                    <StackPanel>
                        <TextBlock Text="PLC IP Address:"/>
                        <TextBox Text="{Binding ApplicationSettings.PLCConfiguration.IPAddress}" Width="200"/>
                        <TextBlock Text="PLC Port:" Margin="0,10,0,0"/>
                        <TextBox Text="{Binding ApplicationSettings.PLCConfiguration.Port}" Width="200"/>
                        <TextBlock Text="PLC Unit ID:" Margin="0,10,0,0"/>
                        <TextBox Text="{Binding ApplicationSettings.PLCConfiguration.UnitID}" Width="200"/>
                        <StackPanel Orientation="Horizontal" Margin="0,10,0,0">
                            <Button Content="Register PLC Endpoints" Command="{Binding RegisterPLCEndpointsCommand}" Width="200" Margin="0,0,10,0"/>
                            <Button Content="Register PLC Startpoints" Command="{Binding CheckPLCConnectionCommand}" Width="200"/>
                            <Button Content="Check PLC" Command="{Binding CheckPLCConnectionCommand}" Width="200"/>

                        </StackPanel>
                    </StackPanel>
                </Grid>
            </TabItem>

            <!-- Image Processing Tab (unchanged) -->
            <TabItem Header="Image Processing">
                <Grid Margin="10">
                    <StackPanel>
                        <TextBlock Text="Image Storage Path:"/>
                        <TextBox Text="{Binding ApplicationSettings.ImageStoragePath}" Width="300"/>
                        <StackPanel Orientation="Horizontal"/>
                        <GroupBox Header="Preprocessing Steps" Margin="0,20,0,0">
                            <Grid>
                                <Grid.ColumnDefinitions>
                                    <ColumnDefinition Width="66*"/>
                                    <ColumnDefinition Width="365*"/>
                                </Grid.ColumnDefinitions>
                                <DataGrid ItemsSource="{Binding ApplicationSettings.PreprocessingSteps}" AutoGenerateColumns="False" Height="150" Grid.ColumnSpan="2" Margin="0,20,0,20">
                                    <DataGrid.Columns>
                                        <DataGridTextColumn Header="Order" Binding="{Binding Order}" Width="50"/>
                                        <DataGridTextColumn Header="Step Name" Binding="{Binding StepName}" Width="*"/>
                                        <DataGridTextColumn Header="Parameters" Binding="{Binding Parameters}" Width="*"/>
                                    </DataGrid.Columns>
                                </DataGrid>
                                <StackPanel Orientation="Horizontal" HorizontalAlignment="Right" Margin="0,160,0,0" Grid.Column="1">
                                    <Button Content="Add Step" Command="{Binding AddPreprocessingStepCommand}" Margin="5"/>
                                    <Button Content="Remove Step" Command="{Binding RemovePreprocessingStepCommand}" Margin="5"/>
                                    <Button Content="Previous" Margin="5"/>
                                    <Button Content="Next" Margin="5"/>
                                </StackPanel>
                            </Grid>
                        </GroupBox>
                    </StackPanel>
                </Grid>
            </TabItem>
        </TabControl>
        <!-- Save Settings Button at the bottom -->
        <StackPanel DockPanel.Dock="Bottom" Orientation="Horizontal" HorizontalAlignment="Right" Margin="10">
            <Button Content="Save Settings" Command="{Binding SaveSettingsCommand}" Width="150"/>
        </StackPanel>
    </DockPanel>
</Window>
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Controls;
using System.Windows.Data;
using System.Windows.Documents;
using System.Windows.Input;
using System.Windows.Media;
using System.Windows.Media.Imaging;
using System.Windows.Shapes;
using Anomaly_Detector.Models;

namespace Anomaly_Detector.Views
{
    /// <summary>
    /// Interaction logic for SettingsWindow.xaml
    /// </summary>
    public partial class SettingsWindow : Window
    {
        public SettingsWindow()
        {
            InitializeComponent();
        }

        private void CameraItem_DoubleClick(object sender, MouseButtonEventArgs e)
        {
            var selectedCamera = (CameraModel)((DataGrid)sender).SelectedItem;
            if (selectedCamera != null)
            {
                // Open the camera screen (you can customize this to open the camera view)
                var cameraWindow = new CameraWindow(selectedCamera);  // Assuming you have a CameraWindow
                cameraWindow.Show();
            }
        }

    }
}
<Application x:Class="Anomaly_Detector.App"
             xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
             xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
             xmlns:local="clr-namespace:Anomaly_Detector"
             StartupUri="MainWindow.xaml">
    <Application.Resources>
         
    </Application.Resources>
</Application>
using System.Configuration;
using System.Data;
using System.Windows;

namespace Anomaly_Detector
{
    /// <summary>
    /// Interaction logic for App.xaml
    /// </summary>
    public partial class App : Application
    {
    }

}
using System.Windows;

[assembly: ThemeInfo(
    ResourceDictionaryLocation.None,            //where theme specific resource dictionaries are located
                                                //(used if a resource is not found in the page,
                                                // or application resource dictionaries)
    ResourceDictionaryLocation.SourceAssembly   //where the generic resource dictionary is located
                                                //(used if a resource is not found in the page,
                                                // app, or any theme specific resource dictionaries)
)]
<Window x:Class="Anomaly_Detector.MainWindow"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        xmlns:d="http://schemas.microsoft.com/expression/blend/2008"
        xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"
        xmlns:local="clr-namespace:Anomaly_Detector"
        mc:Ignorable="d"
        Title="Anomaly Detector" Height="450" Width="800">
    <Grid>
        <StackPanel VerticalAlignment="Center" HorizontalAlignment="Center">
            <TextBlock Text="Anomaly Detector" FontSize="28" FontWeight="Bold" 
                       HorizontalAlignment="Center" Margin="0,0,0,20"/>

            <Button Content="Monitoring" Width="200" Height="45" Click="OpenMonitoringWindow" FontSize="16" BorderThickness="0" Margin="0,5"/>
            <Button Content="Settings" Width="200" Height="45" Click="OpenSettingsWindow"  FontSize="16" BorderThickness="0"/>
        </StackPanel>
    </Grid>
</Window>
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Controls;
using System.Windows.Data;
using System.Windows.Documents;
using System.Windows.Input;
using System.Windows.Media;
using System.Windows.Media.Imaging;
using System.Windows.Shapes;
using Anomaly_Detector.Views;

namespace Anomaly_Detector
{
    /// <summary>
    /// Interaction logic for MainWindow.xaml
    /// </summary>
    public partial class MainWindow : Window
    {
        public MainWindow()
        {
            InitializeComponent();
        }

        private void OpenMonitoringWindow(object sender, RoutedEventArgs e)
        {
            MonitorWindow monitoring = new MonitorWindow();
            monitoring.Show();
        }

        private void OpenSettingsWindow(object sender, RoutedEventArgs e)
        {
            SettingsWindow settings = new SettingsWindow();
            settings.Show();
        }

  
    }
}
